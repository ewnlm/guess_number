#!/usr/bin/perl -w
  use strict;
  use experimental 'smartmatch';
  my @golden;
  my ($iter, $AB, $positively, $move, $currs, $prevs);
  my (@mask, @prev_weight, @curr_weight, @testing, @answer);
  my (@un_test, @tested, @unsuccessful);
  my (%record, %candidate, %removed, %stayed);
  open FP, "golden.txt";
  while(<FP>) {
    chomp($_);
    push @golden, $_;
  }
  close FP;

  for my $goal(@golden) {
    @mask = (1, 1, 1, 1);
    @answer = qw/X X X X/;
    @testing = 1..4;
    @prev_weight = (0,0);
    $prevs = 0;
    %record = ();
    %removed = ();
    %stayed = ();
    @un_test = grep {!($_~~ @testing)} 0..9;
    #print "un test: @un_test\n";
    $iter = 0;
    $AB = &your_result($goal, join "", @testing);
    print "@testing, ($AB, iter: $iter)\n";
    @curr_weight = split /[A|B]/, $AB;
    do {
      ### Get result
      $move = 4-$curr_weight[0]-$curr_weight[1];
      $currs = $curr_weight[0]+$curr_weight[1];
      ### Record
      map {push @{$record{$_}}, $testing[$_]} 0..$#testing;
      push @{$record{4}}, $currs;
      ### 0A0B condition
      if($currs==0) {
	push @unsuccessful, @testing;
	for my $i(0..$#testing) {
	  $removed{$iter}{$i}=$testing[$i];
	}
	### Processing @answer @candidate
	if($prevs>$currs) {
	  if($prev_weight[0]>$curr_weight[0] and exists $removed{$iter-1}) {
	    for my $i(keys %{$removed{$iter-1}}) {
	      $answer[$i] = $removed{$iter-1}{$i};
	    }
	  } elsif($prev_weight[1]>$curr_weight[1] and exists $removed{$iter-1}) {
	    for my $i(keys %{$removed{$iter-1}}) {
	      push @{$candidate{$i}}, $removed{$iter-1}{$i};
	    }
	  }
	}
	for my $i(0..$#answer) {
	  if($answer[$i]!~/X/) {
	    $testing[$i] = $answer[$i]
	  } elsif($#candidate!=-1) {
	    $testing[$i] = pop @candidate;
	  } elsif($#un_test!=-1) {
	    $testing[$i] = pop @un_test;
	  } else {
	    $testing[$i] = pop @tested;
	  }
	}
      }
      ### 0A1B 1A0B conditions
      if($currs==1) {
	if($prevs > $currs) {
	  if($prev_weight[0] > $curr_weight[0]) {
	    for my $i(0..$#answer) {
	      if(exists $removed{$iter-1}{$i}) {
		$answer[$i] = $removed{$iter-1}{$i};
		$testing[$i] = $removed{$iter-1}{$i};
	      } else {

	      }
	    }

	  }
	  if($prev_weight[1] > $curr_weight[1]) {
	    for my $i(keys %{$removed{$iter-1}}) {
	      push @candidate, $removed{$iter-1}{$i};
	    }
	  }
	  ### Pick 2 digits
	} elsif($prevs < $currs) {
	  ### impossible
	  $testing[0] = pop @un_test;
	  $testing[1] = pop @un_test;
	} else {
	  if(@curr_weight~~@prev_weight and exists $removed{$iter-1}) {
	    for my $i(keys %{$removed{$iter-1}}) {
	      push @unsuccessful, $removed{$iter-1}{$i};
	    }
	  } else { ### 0A1B > 1A0B or 1A0B > 0A1B
	    for my $i(keys %{$stayed{$iter-1}} and exists $stayed{$iter-1}) {
	      push @unsuccessful, $stayed{$iter-1}{$i};
	    }
	  }
	  ### Pick 2 digits
	}
	### Processing $removed{$iter} and $stayed{$iter}
	
      }

      if($currs==2 or $currs==3) {

      }

      if($currs==4) {
	@candidate = ();
	push @candidate, @testing;
      }

      ### filter
      my %seen = ();
      @unsuccessful = grep {!($seen{$_}++)} @unsuccessful;

      ###
      @prev_weight = @curr_weight;
      $prevs = $currs;
      $AB = &your_result($goal, join "", @testing);
      @curr_weight = split /[A|B]/, $AB;
      print "@testing, ($AB, iter: $iter)\n";
    } while($iter<2); # $curr_weight[0]==4

    for my $i(sort keys %record) {
      print "Record: $i, @{$record{$i}}\n";
    }

  }



  sub your_result {
    my @ary_i = split //, shift @_;
    my @ary_j = split //, shift @_;
    my @a = map {$ary_i[$_]=~/$ary_j[$_]/} 0..$#ary_i;
    my @b = grep {$_ ~~ @ary_j} @ary_i;
    my $A = ($#a<0)?(0):($#a+1);
    my $B = ($#b<0)?(0):(abs($#b-$#a));
    $iter++;
    my $str = "$A"."A$B"."B";
  }
