#!/usr/bin/perl -w
  use strict;
  use experimental 'smartmatch';
  my @golden;
  my ($iter, $AB, $positively, $move, $currs, $prevs);
  my (@mask, @prev_weight, @weight, @testing, @answer, @un_test, @tested, @unsuccessful);
  open FP, "golden.txt";
  while(<FP>) {
    chomp($_);
    push @golden, $_;
  }
  close FP;

  for my $goal(@golden) {
    @answer = 1..4;
    @mask = (1, 1, 1, 1);
    @testing = @answer;
    @prev_weight = (0,0);
    $prevs = 0;
    @un_test = grep {!($_~~ @answer)} 0..9;
    print "un test: @un_test\n";
    $iter = 0;
    $AB = &your_result($goal, join "", @answer);
    print "$AB, $iter\n";
    do {
      @weight = split /[A|B]/, $AB;
      $move = 4-$weight[0]-$weight[1];
      $currs = $weight[0]+$weight[1];
      ### generate new test pattern - @testing
      #	  consider prev weight(prevs) and curr weight(currs)
      #
      #	  $currs > $prevs is positively
      #	  new pattern from @un_test
      #	  $currs < $prevs is negatively
      #	  new pattern from @tested
      #
      #	  @mask to enable/disable @testing
      #
      #

      @testing = map {($mask[$_])?("X"):($answer[$_])} 0..$#answer;
      print "testing: @testing\n";


      @prev_weight = @weight;
      $prevs = $currs;
      $AB = &your_result($goal, join "", @testing);
      print "$AB, $iter\n";
    } while($iter<2) # $weight[0]==4
  }



  sub your_result {
    my @ary_i = split //, shift @_;
    my @ary_j = split //, shift @_;
    my @a = map {$ary_i[$_]=~/$ary_j[$_]/} 0..$#ary_i;
    my @b = grep {$_ ~~ @ary_j} @ary_i;
    my $A = ($#a<0)?(0):($#a+1);
    my $B = ($#b<0)?(0):(abs($#b-$#a));
    $iter++;
    my $str = "$A"."A$B"."B";
  }
